public class ThanosBot implements Strategy 
{ 
private Card[] hand;
private int playerSeat;
private int phandCategory;

  public void deal(int seat, int handCategory, Card[] h, TableView tableView)
  {
    hand = h;
    playerSeat = seat;
    phandCategory = handCategory;
  }
  
  
// called when it's this player's turn during betting 
// returns FOLD, CALL, or RAISE 
  public int act() 
  { 
  
  
  
  if(HandEvaluator.evaluateHand(hand) >= 2)//2 pairs or higher
  {
  return RAISE;
  
  }
  else if(HandEvaluator.evaluateHand(hand) > 0 || isClose(hand)[0] == 1 || highCard(hand)[0] >= 10  )//1 pair
  {
  return CALL;
  }
  else
  {
  return FOLD; //nothing in hand
  
  }
  } 
  


  public static int[] isClose(Card[] theHand) //finds out if it is close to a straight/flush
  {
  int[] answer = new int[2]; //0 in first value means not close. 1 in first value means close. Second value means whitch card to swtich out.
  answer[0] = 0;
  answer[1] = 5; //5 means that it is not applicable
  for (int i = 1; i < theHand.length; i++) //sorts the hand
  {
    for (int j = i; jh > 0; j--)
    if (theHand[j].getRank() > theHand[j - 1].getRank())
    {
      Card savedCard = theHand[j];
      theHand[j] = theHand[j - 1];
      theHand[j - 1] = savedCard;
    }
  }
  
  //check if close to flush
  int numSpade = 0;
  int numClub = 0;
  int numHeart = 0;
  int numDiamond = 0;
  for (int x = 0; x<hand.length; x++)
  {
    if (theHand[x].getSuit() == 0)
    numSpade++;
    if (theHand[x].getSuit() == 1)
    numClub++;
    if (theHand[x].getSuit() == 2)
    numHeart++;
    if (theHand[x].getSuit() == 3)
    numDiamond++;
  }
  if(numSpade == 4)
  {
    for (int x = 0; x<hand.length; x++)
    {
      if (theHand[x].getSuit() != 0)
      {
        answer[0] = 1;
        answer[1] = x;
        return answer;
      }
    }
  }
  if(numClub == 4)
  {
    for (int x = 0; x<hand.length; x++)
    {
      if (theHand[x].getSuit() != 1)
      {
        answer[0] = 1;
        answer[1] = x;
        return answer;
      }
    }
  }
  if(numHeart == 4)
  {
    for (int x = 0; x<hand.length; x++)
    {
      if (theHand[x].getSuit() != 2)
      {
        answer[0] = 1;
        answer[1] = x;
        return answer;
      }
    }
  }
  if(numDiamond == 4)
  {
    for (int x = 0; x<hand.length; x++)
    {
      if (theHand[x].getSuit() != 3)
      {
        answer[0] = 1;
        answer[1] = x;
        return answer;
      }
    }
  }
  
      
  
  //now check if close to straight
  if (theHand[4].getRank() - theHand[1].getRank())
  {
  answer[0] = 1;
  answer[1] = 0;
  return answer;
  }
  if (theHand[3].getRank() - theHand[0].getRank())
  {
  answer[0] = 1;
  answer[1] = 4;
  return answer;
  }
  
  
  if (theHand[4].getRank() == 14) //ace at the end
  {
  Card temp = theHand[4].getRank();
  for (int y = theHand.length -1; y > 0; y--)
  {
  theHand[y] = theHand[y-1];
  }
  theHand[0] = temp; //puts ace at the front
  return isClose(theHand); //runs same method with ace acting as value 1
  }
  return answer;
  
  }
  
  public static int[] highCard(Card[] h)//returns an array, with the first value being the rank, the second value being its location in your hand, and the third being the total above 10
  {
  int[] rin = new int[3];
  int high = 0;
  int index = 0;
  int numAboveTen = 0;
  for(int x = 0; x < h.length; x ++)
  {
  if(h[x].getRank>10)
  {
  numAboveTen ++;
  }
  if(h[x].getRank() > high)
  {
  high = h[x].getRank();
  index = x;
  
  }

  }
  rin[0] = high;
  rin[1] = index;
  rin[2] = numAboveTen;
  return rin;
  }
  
  
// returns which cards to exchange; 
// for example, {true, false, true, false, false} means discard cards at index 0 and 2 
  public boolean[] exchange() //needs to be edited, currently just random
  { 
    boolean[] exchange = new boolean[5]; 
    for (int i=0; i<5; i++) 
    { 
      int random = (int)(Math.random() * 2); 
      if (random==0) 
        exchange[i] = true; 
      else 
        exchange[i] = false; 
    } 
    return exchange; 
  } 
  
  public void exchanged(int handCategory, Card[] hand)
  {
  }
  
  public void roundEnded()
  {
  }
} 
